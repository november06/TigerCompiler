package tiger.parse;
import tiger.absyn.*;
// import tiger.symbol.*;

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
	LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
	TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
	ASSIGN, 
    ARRAY, BREAK, DO, ELSE, END, FOR, FUNCTION, IF, 
	IN, LET, NIL, OF, THEN, TO, TYPE, VAR, WHILE;


non terminal program; // done
non terminal expr;    // done
non terminal lvalue;  // done
non terminal binary_operator; // done
non terminal expr_list;  // done
non terminal expr_seq;   // done
// non terminal type_id;    // done
non terminal field_list; // done
non terminal declaration_list; // done
non terminal declaration;     // done
non terminal type_declaration;// done
non terminal variable_declaration; // done 
non terminal function_declaration; // done
non terminal type;            // done
non terminal type_fields;     // done
non terminal type_field;      // done

precedence nonassoc ASSIGN;
precedence left AND, OR;  // right?
precedence nonassoc EQ, NEQ, LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
// precedence left UMINUS; // TODO

start with program;

program ::= expr;
// expr with values and without values
expr ::= STRING:s 
         {:
		     RESULT = new LiteralExp(sleft, s);
		 :} 
         |
         INT:i
		 {:
		     RESULT = new LiteralExp(ileft, i);
		 :} 
		 |
		 NIL:n
		 {:
		     RESULT = new LiteralExp(nleft);
		 :} 
		 |
		 lvalue:l
		 {:
		     RESULT = l;
		 :}
		 |
		 MINUS:uminus expr:e 
		 {:
		     RESULT = new UminusExp(uminusleft, (Exp)e);
		 :}
		 | 
		 expr:e1 binary_operator:op expr:e2 
		 {:
		     RESULT = new BinaryOperationExp(e1left, (Exp)e1, (Integer)op, (Exp)e2);
		 :}
		 |
		 lvalue:lvalueExpr ASSIGN expr:rvalueExpr
		 {:
		     RESULT = new AssignExp(lvalueExprleft, (LvalueExp)lvalueExpr, (Exp)rvalueExpr);
		 :} 
		 | 
		 ID:id LPAREN expr_list:exprlist RPAREN 
		 {:
		     RESULT = new FunctionCallExp(idleft, id, (Exp)exprlist);
		 :}
		 | // function call
		 LPAREN expr_seq:e RPAREN 
		 {:
		     RESULT = e;
		 :}
		 | 
         // type_id LBRACE field_list RBRACE |
		 ID LBRACE field_list RBRACE 
		 |
		 // type_id LBRACK expr RBRACK OF expr |
		 ID LBRACK expr RBRACK OF expr 
		 |
		 IF:i expr:condition THEN expr:e1 
		 {:
		     RESULT = new IfElseExp(ileft, (Exp)condition, (Exp)e1);
		 :}
		 | 
		 IF:i expr:condition THEN expr:e1 ELSE expr:e2
		 {:
		     RESULT = new IfElseExp(ileft, (Exp)condition, (Exp)e1, (Exp)e2);
		 :}
		 | 
		 WHILE:w expr:condition DO expr:e 
		 {:
		     RESULT = new WhileExp(wleft, (Exp)condition, (Exp)e);
		 :}
		 | 
		 FOR ID ASSIGN expr TO expr DO expr 
		 {:
		     //
		 :}
		 | 
		 BREAK 
		 | // ?
		 LET declaration_list IN expr_seq END
		 ;

expr_seq ::= expr:e
             {:
			     RESULT = new SeqExp(eleft, (Exp)e);
			 :} 
             |
             expr_seq:e1 SEMICOLON expr:e2
			 {:
			     RESULT = new SeqExp(e1left, (Exp)e1, (Exp)e2);
			 :}
			 ;

expr_list ::= expr:e
              {:
			      RESULT = new ListExp(eleft, (Exp)e);
			  :} 
              |
              expr_list:head COMMA expr:tail
			  {:
			      RESULT = new ListExp(headleft, (Exp)head, (Exp)tail);
			  :};

field_list ::= ID EQ expr |
               field_list COMMA ID EQ expr;

lvalue ::= ID:id
           {:
		       RESULT = new LvalueExp(idleft, id);
		   :} 
           |
           lvalue:lvalueExp DOT ID:fieldId
		   {:
		       RESULT = new LvalueExp(lvalueExpleft, (LvalueExp)lvalueExp, fieldId);
		   :}
		   |
		   lvalue:lvalueExp LBRACK expr:exp RBRACK
		   {:
		       RESULT = new LvalueExp(lvalueExpleft, (LvalueExp)lvalueExp, (Exp)exp);
		   :}
		   ;

binary_operator ::= PLUS 
                    {:
					    RESULT = BinaryOperationExp.PLUS;
					:}
					|
                    MINUS
					{:
					    RESULT = BinaryOperationExp.MINUS;
					:} 
					| 
					TIMES
					{:
					    RESULT = BinaryOperationExp.TIMES;
					:} 
					|
					DIVIDE 
					{:
					    RESULT = BinaryOperationExp.DIVIDE;
					:}
					| 
					EQ 
					{:
					    RESULT = BinaryOperationExp.EQ;
					:}
					|
					NEQ 
					{:
					    RESULT = BinaryOperationExp.NE;
					:}
					| 
					LT 
					{:
					    RESULT = BinaryOperationExp.LT;
					:}
					|
					GT
					{:
					    RESULT = BinaryOperationExp.GT;
					:} 
					|
					LE 
					{:
					    RESULT = BinaryOperationExp.LE;
					:}
					|
					GE 
					{:
					    RESULT = BinaryOperationExp.GE;
					:}
					|
					AND 
					{:
					    RESULT = BinaryOperationExp.AND;
					:}
					|
					OR
					{:
					    RESULT = BinaryOperationExp.OR;
					:} 
					;

declaration_list ::= declaration |
                    declaration_list declaration;

declaration ::= type_declaration | 
                variable_declaration | 
				function_declaration ;

type_declaration ::= TYPE ID EQ type;// TYPE type_id EQ type;

type ::= // type_id |
         ID | 
         LBRACE type_fields RBRACE |
		 ARRAY OF ID;
		 // ARRAY OF type_id;

type_fields ::= type_field |
                type_fields COMMA type_field;

type_field ::= ID COLON ID;// ID COLON type_id;

// type_id ::= ID;

variable_declaration ::= VAR ID ASSIGN expr |
                         VAR ID COLON ID ASSIGN expr;
                         //VAR ID COLON type_id ASSIGN expr;

function_declaration ::= FUNCTION ID LPAREN type_fields RPAREN EQ expr |
                         // FUNCTION ID LPAREN type_fields RPAREN COLON type_id EQ expr;
						 FUNCTION ID LPAREN type_fields RPAREN COLON ID EQ expr;